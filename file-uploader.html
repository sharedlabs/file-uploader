<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="file-uploader-progress-overlay.html">
<link rel="import" href="file-uploader-completed-overlay.html">

<!--
`file-uploader`

@demo demo/index.html
-->
<script>
(function() {
  'use strict';

  Polymer({

    is: 'file-uploader',

    properties: {

      /**
       * Files that are currently being uploaded.
       * It's a Map where keys are files and values are upload details.
       */
      uploadingFiles: {
        type: Map,
        readOnly: true,
        value: _ => {
          return new Map();
        }
      },

      // @optional
      url: String,

      // @optional
      method: {
        type: String,
        value: 'POST',
      },

      // @optional
      headers: Object,

      uploading: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      // Current XMLHTTPRequest
      _currentXHR: Object

    },

    /**
     * Add a single file to the uploading queue.
     * 
     * @param {!File}
     */
    addFile(file, options) {
      if (!this._isFileOnQueue(file)) {
        this.uploadingFiles.set(file, {xhrParams: options, state: 'queued'});

        if (!this.uploading) {
          this._uploadStart();
        }
      }
    },

    cancelUpload() {
      if (this.uploading) {
        if (this._currentXHR) {
          this._currentXHR.abort();
        }
        this._uploadEnd({canceled: true});
      }
    },

    _resumeQueue() {
      let nextQueuedItem;

      for (const [file, detail] of this.uploadingFiles) {
        if (detail.state === 'queued') {
          nextQueuedItem = {file, detail};
          break;
        }
      }
      
      if (nextQueuedItem) {
        this._uploadFile(nextQueuedItem.file, nextQueuedItem.detail.xhrParams);
      } else {
        this._uploadEnd();
      }
    },
    
    _uploadStart() {
      if (this.uploading) {
        return;
      }

      this._setUploading(true);
      this.fire('upload-start');

      if (this._completedOverlay) {
        this._completedOverlay.opened = false;
      }

      this._progressOverlay = this.create('file-uploader-progress-overlay', {
        opened: true,
        uploadingFiles: this.uploadingFiles
      });

      this._progressOverlay.addEventListener('stop-upload-tapped', _ => {
        this.cancelUpload();
      });

      this._resumeQueue();
    },

    _uploadFile(file, xhrParams) {
      if (!this.uploading) {
        return;
      }

      this._progressOverlay.currentFile = file;
      const detail = this.uploadingFiles.get(file);

      this._xhr(xhrParams).then(response => {
        const data = {file, url: response.url};

        detail.state = 'uploaded';
        this.fire('file-uploaded', {file, detail});
        return data;
      }).catch(error => {
        detail.state = 'failed';
        detail.error = error;
        this.fire('error', {file, detail});
        throw error;
      }).then(_ => {
        this._resumeQueue();
      });
    },

    _uploadEnd(canceled = false) {
      if (!this.uploading) {
        return;
      }

      const files = [];

      for (const [file, detail] of this.uploadingFiles) {
        files.push(file);
      }

      this._setUploading(false);
      this._progressOverlay.opened = false;
      this._progressOverlay = null;
      this.uploadingFiles.clear();

      if (canceled) {
        this.fire('upload-canceled', {files});
      } else {
        this.fire('upload-end', {files});
      }

      // Display completed overlay
      if (this._completedOverlay) {
        this._completedOverlay.files = this._completedOverlay.files.concat(files);
        this._completedOverlay.opened = true;
      } else {
        this._completedOverlay = this.create('file-uploader-completed-overlay', {
          opened: true,
          files: files,
          onDetach: _ => {
            this._completedOverlay = null;
          }
        });
      }
    },

    _isFileOnQueue(file) {
      let result = false;

      for (let [f, detail] of this.uploadingFiles) {
        if (f.name === file.name && f.size === file.size) {
          result = true;
          break;
        }
      }

      return result;
    },

    _xhr({file, url = this.url, method = this.method, headers = this.headers} = {}) {
      return new Promise((resolve, reject) => {
        if (!url) {
          return reject(new Error('file-uploader requires an URL'));
        }

        const xhr = new XMLHttpRequest();

        xhr.addEventListener('loadend', _ => {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve({file, url});
          } else {
            reject(xhr.statusText);
          }
        });

        xhr.addEventListener('error', event => {
          reject(event.currentTarget.response);
        });

        xhr.open(method, url, true);

        if (headers) {
          const constructorName = headers.constructor.name;
          if (constructorName === 'Headers') {
            headers.forEach(xhr.setRequestHeader.bind(xhr));
          } else if (constructorName === 'Object') {
            Object.keys(headers).forEach(name => {
              xhr.setRequestHeader(name, headers[name]);
            });
          } else {
            return reject(
              new Error('Invalid headers. Object or Header instance allowed'));
          }
        }

        xhr.send(file);
        this._currentXHR = xhr;
      });
    },

  });

}());
</script>
