<link rel="import" href="../polymer/polymer.html">

<!--
`file-uploader`

@demo demo/index.html
-->

<!-- <dom-module id="file-uploader">
  <template>

    <style>
      :host {
        display: none;
      }
    </style>

  </template>
</dom-module>
 -->
<script>
(function() {
  'use strict';

  Polymer({

    is: 'file-uploader',

    properties: {

      url: {
        type: String,
      },

      method: {
        type: String,
        value: 'POST',
      },

      headers: {
        type: Object,
      },

      beforeUpload: {
        type: Function,
      },

      progress: {
        type: Number,
        // notify: true,
        readOnly: true,
      },

      files: {
        type: Array,
        value: _ => [],
        notify: true,
        readOnly: true,
      },

      filesProgress: {
        type: WeakMap,
        value: _ => new WeakMap(),
        notify: true,
        readOnly: true,
      },

      filesRequests: {
        type: WeakMap,
        value: _ => new WeakMap(),
        notify: true,
        readOnly: true,
      },

      failure: {
        type: String,
        notify: true,
        readOnly: true,
      },

      _stopped: {
        type: Boolean,
        value: false,
      },

      /*
       * Last XMLHTTPRequest sent
       */
      _xhrObject: {
        type: Object,
      }

    },

    get filesInProgress() {
      return this.files.filter(file => {
        const progress = this.filesProgress.get(file);
        const isUploading = typeof progress === 'number' && progress < 100;
        return isUploading;
      });
    },

    uploadFile(file) {
      if (this.progress === 100) {
        this._clearUpload();
      }

      if (!this._isFileAdded(file)) {
        this.push('files', file);
        this.resumeUpload();
      }
    },

    cancelUpload() {
      if (this._xhrObject) {
        this._xhrObject.abort();
      }
      this.fire('upload-canceled', {files: this.files.slice(0)});
      this._clearUpload();
    },

    stopUpload() {
      this._stopped = true;
    },

    resumeUpload() {
      this._stopped = false;

      for (const file of this.files) {
        const progress = this.filesProgress.get(file);
        const isUploading = typeof progress === 'number' && progress < 100;
        const fileUploadFailed = progress === null;
        const isUploaded = progress === 100;

        if (isUploading) {
          // Wait: Only one at a time
          break;
        // Ignore failed files.
        } else if (!isUploaded && !fileUploadFailed) {
          this._startFileUpload(file);
          break;
        }
      }
    },

    retryFailedUploads() {
      for (const file of this.files) {
        const fileUploadFailed = this.filesProgress.get(file) === null;

        if (fileUploadFailed) {
          this.filesProgress.delete(file);
        }
      }
      this.resumeUpload();
    },

    _startFileUpload(file) {
      const request = Promise.resolve().then(_ => {
        return this._beforeUpload(file)
          .then(this._xhr.bind(this))
          .then(response => {
            const data = {file, url: response.url};
            this.filesProgress.set(file, 100);
            this._updateProgress();
            this.fire('upload-finished', data);

            // Download next one
            if (!this._stopped) {
              this.resumeUpload();
            }

            return data;
          })
          .catch(err => {
            this.filesProgress.set(file, null);
            this._setFailure(err && err.toString() ||
              `Error uploading ${file.name}`);
            this.fire('upload-failed', {file});
            throw err;
          });
      });

      this.filesProgress.set(file, 0);
      this.filesRequests.set(file, request);
      this._updateProgress();
      this.fire('upload-started', {request, file});
    },

    _beforeUpload(file) {
      if (typeof this.beforeUpload === 'function') {
        return this.beforeUpload(file).then(config => {
          config = config || {};
          config.file = file;
          return config;
        });
      }
      return {file};
    },

    _updateProgress() {
      if (this.files.length === 0) {
        this._setProgress(null);
      } else {
        const completedFiles = this.files.filter(file => {
          return this.filesProgress.get(file) === 100;
        }) ||Â [];
        const progress = completedFiles.length * 100 / this.files.length;
        this._setProgress(Math.round(progress));
      }
      this.fire('progress-changed', this.progress);
    },

    _clearUpload() {
      this.files.splice(0);
      this._setFailure(null);
      this._updateProgress();
    },

    _isFileAdded(file) {
      return this.files.find(f => {
        return f.name === file.name && f.size === file.size;
      });
    },

    _xhr({file, url=this.url, method=this.method, headers=this.headers}={}) {
      return new Promise((resolve, reject) => {
        if (!url) {
          return reject(new Error('No url'));
        }
        if (!file) {
          return reject(new Error('No file'));
        }

        const xhr = new XMLHttpRequest();
        xhr.addEventListener('load', e => resolve({file, url}));
        xhr.addEventListener('error', e => reject(e.currentTarget.response));
        xhr.open(method, url, true);

        if (headers) {
          const constructorName = headers.constructor.name;
          if (constructorName === 'Headers') {
            headers.forEach(xhr.setRequestHeader.bind(xhr));
          } else if (constructorName === 'Object') {
            Object.keys(headers).forEach(name => {
              xhr.setRequestHeader(name, headers[name]);
            });
          } else {
            return reject(
              new Error('Invalid headers. Object or Header instance allowed'));
          }
        }

        xhr.send(file);
        this._xhrObject = xhr;
      });
    },

  });

}());
</script>
