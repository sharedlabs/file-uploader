<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../input-file/input-file.html">

<!--
`file-uploader`

@demo demo/index.html
-->

<!-- <dom-module id="file-uploader">
  <template>

    <style>
      :host {
        display: none;
      }
    </style>

  </template>
</dom-module>
 -->
<script>
(function() {
  'use strict';

  Polymer({

    is: 'file-uploader',

    properties: {

      url: {
        type: String,
      },

      headers: {
        type: Object,
      },

      beforeUpload: {
        type: Function,
      },

      progress: {
        type: Number,
        notify: true,
        readOnly: true,
      },

      files: {
        type: Array,
        value: _ => [],
        notify: true,
        readOnly: true,
      },

      filesProgress: {
        type: WeakMap,
        value: _ => new WeakMap(),
        notify: true,
        readOnly: true,
      },

      failure: {
        type: String,
        notify: true,
        readOnly: true,
      },

    },

    uploadFile(files) {
      if (files.constructor.name === 'File') {
        files = [files];
      }

      if (this.progress === 100) {
        this._clearUpload();
      }

      for (const file of files) {
        if (!this._isFileAdded(file)) {
          this.files.push(file);
        }
      }
      this.resumeUpload();
    },

    resumeUpload() {
      for (const file of this.files) {
        if (typeof this.filesProgress.get(file) === 'number') {
          continue;
        }

        Promise.resolve()
          .then(this._beforeUpload.bind(this, file))
          .then(this._xhr.bind(this))
          .then(_ => {
            this.filesProgress.set(file, 100);
            this._updateProgress();
          })
          .catch(err => {
            this.filesProgress.set(file, null);
            this._setFailure(err && err.toString() ||
              `Error uploading ${file.name}`);
          });
        this.filesProgress.set(file, 0);
      }

      this.async(_ => this._updateProgress());
    },

    _beforeUpload(file) {
      if (typeof this.beforeUpload === 'function') {
        return this.beforeUpload(file).then(config => {
          config = config || {};
          config.file = file;
          return config;
        });
      }
      return {file};
    },

    _updateProgress() {
      const completedFiles = this.files.find(file => {
        return this.filesProgress.get(file) === 100;
      }) ||Â [];
      const progress = completedFiles.length / this.files.length;
      this._setProgress(Math.round(progress));
    },

    _clearUpload() {
      this._setFailure(null);
      this.files.splice(0);
      this._setProgress(null);
    },

    _isFileAdded(file) {
      return this.files.find(f => {
        return f.name === file.name && f.size === file.size;
      });
    },

    _xhr({file, url=this.url, headers=this.headers}={}) {
      return new Promise((resolve, reject) => {
        if (!url) {
          return reject(new Error('No url'));
        }
        if (!file) {
          return reject(new Error('No file'));
        }

        const xhr = new XMLHttpRequest();
        xhr.addEventListener('load', e => resolve(e.currentTarget.response));
        xhr.addEventListener('error', e => reject(e.currentTarget.response));
        xhr.open('POST', url);

        if (headers) {
          const constructorName = headers.constructor.name;
          if (constructorName === 'Headers') {
            headers.forEach(xhr.setRequestHeader.bind(xhr));
          } else if (constructorName === 'Object') {
            Object.keys(headers).forEach(name => {
              xhr.setRequestHeader(name, headers[name]);
            });
          } else {
            return reject(
              new Error('Invalid headers. Object or Header instance allowed'));
          }
        }
        xhr.send(file);
      });
    },

  });

}());
</script>
