<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="file-uploader-progress-overlay.html">
<link rel="import" href="file-uploader-completed-overlay.html">

<!--
`file-uploader`

@demo demo/index.html
-->
<script>
(function() {
  'use strict';

  Polymer({

    is: 'file-uploader',

    properties: {

      // Files that are currently being uploaded
      uploadingFiles: {
        type: Array,
        readOnly: true,
        value: _ => []
      },

      url: String,

      method: {
        type: String,
        value: 'POST',
      },

      headers: Object,

      uploading: {
        type: Boolean,
        readOnly: true,
        value: false
      },

      // Current XMLHTTPRequest
      _currentXHR: Object,

      _filesUploadDetail: {
        type: WeakMap,
        value: _ => {
          return new WeakMap();
        }
      }

    },

    /**
     * Add a single file to the uploading queue.
     * @param {!File}
     */
    addFile(file) {
      if (!this._isFileOnQueue(file)) {
        this.push('uploadingFiles', file);

        if (!this.uploading) {
          this._uploadStart();
        }
      }
    },

    cancelUpload() {
      if (this.uploading) {
        if (this._currentXHR) {
          this._currentXHR.abort();
        }
        this._uploadEnd();
        this.fire('file-upload-canceled', {files: this.uploadingFiles});
      }
    },

    _resumeQueue() {
      for (const file of this.uploadingFiles) {
        if (!this._filesUploadDetail.get(file)) {
          this._upload(file);
          break;
        }
      }
    },
    
    _uploadStart() {
      if (this.uploading) {
        return;
      }

      this._setUploading(true);
      this.fire('file-upload-start');

      this._progressOverlay = this.create('file-uploader-progress', {
        opened: true,
        uploadingFiles: this.uploadingFiles,
        filesUploadDetail: this._filesUploadDetail
      });

      this._progressOverlay.addEventListener('request-cancel-upload', _ => {
        this.cancelUpload();
      });

      this._resumeQueue();
    },

    _upload(file) {
      if (!this.uploading) {
        return;
      }

      this._progressOverlay.currentFile = file;

      this._xhr().then(response => {
        const data = {file, url: response.url};

        this._filesUploadDetail.set(file, {state: 'uploaded'});
        this.fire('file-uploaded', data);
        return data;
      }).catch(error => {
        this._filesUploadDetail.set(file, {state: 'failed'});
        this.fire('file-upload-error', {file, error});
        throw error;
      }).then(_ => {
        this._resumeQueue();
      });
    },

    _uploadEnd() {
      if (!this.uploading) {
        return;
      }

      this.fire('file-upload-end');
      this._progressOverlay.opened = false;
      // this._progressOverlay is automatically removed when it's closed
      this._progressOverlay = null;
      this._filesUploadDetail = new WeakMap();
      this.uploadingFiles([]);
      this._setUploading(false);
    },

    _isFileOnQueue(file) {
      return this.uploadingFiles.find(f => {
        return f.name === file.name && f.size === file.size;
      });
    },

    _xhr({file, url = this.url, method = this.method, headers = this.headers} = {}) {
      return new Promise((resolve, reject) => {
        if (!url) {
          return reject(new Error('file-uploader requires an URL'));
        }

        const xhr = new XMLHttpRequest();

        xhr.addEventListener('loadend', _ => {
          if (xhr.status >= 200 && xhr.status < 300) {
            resolve({file, url});
          } else {
            reject(xhr.statusText);
          }
        });

        xhr.addEventListener('error', event => {
          reject(event.currentTarget.response);
        });

        xhr.open(method, url, true);

        if (headers) {
          const constructorName = headers.constructor.name;
          if (constructorName === 'Headers') {
            headers.forEach(xhr.setRequestHeader.bind(xhr));
          } else if (constructorName === 'Object') {
            Object.keys(headers).forEach(name => {
              xhr.setRequestHeader(name, headers[name]);
            });
          } else {
            return reject(
              new Error('Invalid headers. Object or Header instance allowed'));
          }
        }

        xhr.send(file);
        this._currentXHR = xhr;
      });
    },

  });

}());
</script>
